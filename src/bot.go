package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	commons "github.com/bbernhard/imagemonkey-core/commons"
	datastructures "github.com/bbernhard/imagemonkey-core/datastructures"
	"github.com/getsentry/raven-go"
	"github.com/gofrs/uuid"
	"github.com/google/go-github/github"
	_ "github.com/lib/pq"
	log "github.com/sirupsen/logrus"
	"golang.org/x/oauth2"
	"gopkg.in/resty.v1"
	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
	http "gopkg.in/src-d/go-git.v4/plumbing/transport/http"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"time"
)

var db *sql.DB

type TravisCiBuildInfo struct {
	LastBuild struct {
		State string `json:"state"`
		Id    int64  `json:"id"`
	} `json:"last_build"`
	JobUrl string `json:"job_url"`
}

type TravisCiApi struct {
	repoOwner string
	repo      string
	token     string
}

func NewTravisCiApi(repoOwner string, repo string) *TravisCiApi {
	return &TravisCiApi{
		repoOwner: repoOwner,
		repo:      repo,
	}
}

func (p *TravisCiApi) SetToken(token string) {
	p.token = token
}

func (p *TravisCiApi) GetBuildInfo(branchName string) (TravisCiBuildInfo, error) {

	url := "https://api.travis-ci.org/repo/" + p.repoOwner + "%2F" + p.repo + "/branch/" + branchName

	var travisCiBuildInfo TravisCiBuildInfo

	resp, err := resty.R().
		SetHeader("Content-Type", "application/json").
		SetHeader("Accept", "application/json").
		SetHeader("Travis-API-Version", "3").
		SetHeader("Authorization", "token "+p.token).
		SetResult(&travisCiBuildInfo).
		Get(url)

	if err != nil {
		return travisCiBuildInfo, err
	}

	if !((resp.StatusCode() >= 200) && (resp.StatusCode() <= 209)) {
		return travisCiBuildInfo, errors.New(resp.String())
	}
	log.Info(resp.String())
	travisCiBuildInfo.JobUrl = ("https://travis-ci.org/" + p.repoOwner + "/" + p.repo +
		"/builds/" + strconv.FormatInt(travisCiBuildInfo.LastBuild.Id, 10))
	return travisCiBuildInfo, nil
}

func (p *TravisCiApi) StartBuild(branchName string) error {
	type TravisRequest struct {
		Request struct {
			Branch string `json:"branch"`
		} `json:"request"`
	}

	var req TravisRequest
	req.Request.Branch = branchName

	url := "https://api.travis-ci.org/repo/" + p.repoOwner + "%2F" + p.repo + "/requests"

	resp, err := resty.R().
		SetHeader("Content-Type", "application/json").
		SetHeader("Accept", "application/json").
		SetHeader("Travis-API-Version", "3").
		SetHeader("Authorization", "token "+p.token).
		SetBody(&req).
		Post(url)

	if err != nil {
		return err
	}

	if !((resp.StatusCode() >= 200) && (resp.StatusCode() <= 209)) {
		return errors.New(resp.String())
	}
	return nil

}

type LabelsWriter struct {
	path string
}

func NewLabelsWriter(path string) *LabelsWriter {
	return &LabelsWriter{
		path: path,
	}
}

func (p *LabelsWriter) GetFullPath() string {
	return p.path
}

func (p *LabelsWriter) GetFilename() string {
	return filepath.Base(p.path)
}

func (p *LabelsWriter) Add(name string, entry datastructures.LabelMapEntry) error {
	var labelMap datastructures.LabelMap

	data, err := ioutil.ReadFile(p.path)
	if err != nil {
		return err
	}

	err = json.Unmarshal([]byte(data), &labelMap)
	if err != nil {
		return err
	}

	labelMap.LabelMapEntries[name] = entry

	out, err := json.Marshal(&labelMap)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(p.path, out, 0644)

	return err
}


type MetaLabelsWriter struct {
	path string
}

func NewMetaLabelsWriter(path string) *MetaLabelsWriter {
	return &MetaLabelsWriter{
		path: path,
	}
}

func (p *MetaLabelsWriter) GetFullPath() string {
	return p.path
}

func (p *MetaLabelsWriter) GetFilename() string {
	return filepath.Base(p.path)
}

func (p *MetaLabelsWriter) Add(name string, entry datastructures.MetaLabelMapEntry) error {
	var labelMap datastructures.MetaLabelMap

	data, err := ioutil.ReadFile(p.path)
	if err != nil {
		return err
	}

	err = json.Unmarshal([]byte(data), &labelMap)
	if err != nil {
		return err
	}

	labelMap.MetaLabelMapEntries[name] = entry

	out, err := json.Marshal(&labelMap)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(p.path, out, 0644)

	return err
}


type LabelsRepository struct {
	projectOwner              string
	repositoryName            string
	repositoryUrl             string
	githubToken               string
	gitWorktree               *git.Worktree
	gitRepository             *git.Repository
	gitCheckoutDir            string
	autoGeneratedLabelsWriter *LabelsWriter
	autoGeneratedMetaLabelsWriter *MetaLabelsWriter
}

func NewLabelsRepository(projectOwner string, repositoryName string, gitCheckoutDir string) *LabelsRepository {
	return &LabelsRepository{
		projectOwner:              projectOwner,
		repositoryName:            repositoryName,
		gitCheckoutDir:            gitCheckoutDir,
		repositoryUrl:             "https://github.com/" + projectOwner + "/" + repositoryName,
		autoGeneratedLabelsWriter: NewLabelsWriter(gitCheckoutDir + "/test.json"),
		autoGeneratedMetaLabelsWriter: NewMetaLabelsWriter(gitCheckoutDir + "/test.json"),
	}
}

func (p *LabelsRepository) SetToken(token string) {
	p.githubToken = token
}

func (p *LabelsRepository) Clone() error {
	if _, err := os.Stat(p.gitCheckoutDir); os.IsNotExist(err) {
		p.gitRepository, err = git.PlainClone(p.gitCheckoutDir, false, &git.CloneOptions{
			URL:      p.repositoryUrl,
			Progress: os.Stdout,
		})

		if err != nil {
			return errors.New("Couldn't clone " + p.repositoryUrl + ": " + err.Error())
		}

		p.gitWorktree, err = p.gitRepository.Worktree()
		if err != nil {
			return errors.New("Couldn't get worktree: " + err.Error())
		}
	} else { //git dir exists
		p.gitRepository, err = git.PlainOpen(p.gitCheckoutDir)
		if err != nil {
			return errors.New("Couldn't open " + p.gitCheckoutDir + ": " + err.Error())
		}

		p.gitWorktree, err = p.gitRepository.Worktree()
		if err != nil {
			return errors.New("Couldn't get worktree: " + err.Error())
		}
	}

	return nil
}

func (p *LabelsRepository) AddLabelAndPushToRepo(trendingLabel TrendingLabel) (string, error) {
	branchNameUuid, err := uuid.NewV4()
	if err != nil {
		return "", errors.New("Couldn't create branch name: " + err.Error())
	}

	err = createGitBranch(p.gitWorktree, branchNameUuid.String())
	if err != nil {
		return "", errors.New("Couldn't create git branch " + branchNameUuid.String() + ": " + err.Error())
	}


	if trendingLabel.LabelType == "normal" {
		labelEntry, err := generateLabelEntry(trendingLabel.Name)
		if err != nil {
			return "", errors.New("Couldn't generate label entry: " + err.Error())
		}

		err = p.autoGeneratedLabelsWriter.Add(trendingLabel.Name, labelEntry)
		if err != nil {
			return "", errors.New("Couldn't add label: " + err.Error())
		}

		err = gitAdd(p.gitWorktree, p.autoGeneratedLabelsWriter.GetFilename())
		if err != nil {
			return "", errors.New("Couldn't add file: " + err.Error())
		}
	} else if trendingLabel.LabelType == "meta" {
		metaLabelEntry, err := generateMetaLabelEntry(trendingLabel.Name)
		if err != nil {
			return "", errors.New("Couldn't generate label entry: " + err.Error())
		}

		err = p.autoGeneratedMetaLabelsWriter.Add(trendingLabel.Name, metaLabelEntry)
		if err != nil {
			return "", errors.New("Couldn't add label: " + err.Error())
		}

		err = gitAdd(p.gitWorktree, p.autoGeneratedMetaLabelsWriter.GetFilename())
		if err != nil {
			return "", errors.New("Couldn't add file: " + err.Error())
		}
	} else {
		return "", errors.New("Invalid label type " + trendingLabel.LabelType)
	}

	err = gitCommit(p.gitWorktree, "added label "+trendingLabel.Name)
	if err != nil {
		return "", errors.New("Couldn't commit: " + err.Error())
	}

	err = gitPush(p.gitRepository, p.githubToken)
	if err != nil {
		return "", errors.New("Couldn't push: " + err.Error())
	}

	return branchNameUuid.String(), nil
}

func (p *LabelsRepository) MergeRemoteBranchIntoMaster(branchName string) error {
	ctx := context.Background()
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: p.githubToken},
	)
	tc := oauth2.NewClient(ctx, ts)

	client := github.NewClient(tc)

	//create a new comment
	newPullRequest := &github.NewPullRequest{
		Title: github.String("test"),
		Head:  github.String(branchName),
		Base:  github.String("master"),
	}

	pullRequest, _, err := client.PullRequests.Create(ctx, p.projectOwner, p.repositoryName, newPullRequest)
	if err != nil {
		return err
	}

	_, _, err = client.PullRequests.Merge(ctx, p.projectOwner, p.repositoryName, *pullRequest.Number, "merged", &github.PullRequestOptions{})

	return err
}

func (p *LabelsRepository) RemoveRemoteBranch(branchName string) error {
	ctx := context.Background()
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: p.githubToken},
	)
	tc := oauth2.NewClient(ctx, ts)

	client := github.NewClient(tc)

	ref, _, err := client.Git.GetRef(ctx, p.projectOwner, p.repositoryName, "heads/"+branchName)
	if err != nil {
		return err
	}

	_, err = client.Git.DeleteRef(ctx, p.projectOwner, p.repositoryName, ref.GetRef())
	return err
}

func (p *LabelsRepository) RemoveLocal() error {
	return os.RemoveAll(p.gitCheckoutDir)
}

func gitPull(worktree *git.Worktree) error {
	err := worktree.Pull(&git.PullOptions{RemoteName: "origin"})
	if err != nil && err == git.NoErrAlreadyUpToDate {
		return nil
	}

	return nil
}

func gitPush(repository *git.Repository, apiToken string) error {
	err := repository.Push(&git.PushOptions{
		RemoteName: "origin",
		Auth: &http.BasicAuth{
			Username: "imagemonkeybot",
			Password: apiToken,
		},
	})
	return err
}

func createGitBranch(worktree *git.Worktree, name string) error {
	branch := plumbing.NewBranchReferenceName(name)
	return worktree.Checkout(&git.CheckoutOptions{Branch: branch, Create: true})
}

func gitAdd(worktree *git.Worktree, filename string) error {
	_, err := worktree.Add(filename)
	return err
}

func gitCommit(worktree *git.Worktree, commitMsg string) error {
	_, err := worktree.Commit(commitMsg, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "ImageMonkeyBot",
			Email: "bot@imagemonkey.io",
			When:  time.Now(),
		},
	})

	return err
}

func setTrendingLabelBotTaskState(status string, branchName string, jobUrl string, id int64) error {
	var queryValues []interface{}
	queryValues = append(queryValues, status)
	queryValues = append(queryValues, branchName)
	queryValues = append(queryValues, id)
	jobUrlStr := ""
	if jobUrl != "" {
		jobUrlStr = ", job_url = $4"
		queryValues = append(queryValues, jobUrl)
	}

	q := fmt.Sprintf(`UPDATE trending_label_bot_task 
					  	SET state = $1, branch_name = $2%s
						WHERE id = $3`, jobUrlStr)
	_, err := db.Exec(q, queryValues...)
	return err
}

func resetTrendingLabelBotTaskState(id int64) error {
	_, err := db.Exec(`UPDATE trending_label_bot_task
						SET state = 'accepted', branch_name = null, job_url = null,
						try = try + 1
						WHERE id = $1`, id)
	return err
}

type TrendingLabel struct {
	Name       string `json:"name"`
	BotTaskId  int64  `json:"bot_task_id"`
	State      string `json:"state"`
	BranchName string `json:"branch_name"`
	LabelType string `json:"label_type"`
}

func getTrendingLabels() ([]TrendingLabel, error) {
	trendingLabels := []TrendingLabel{}

	rows, err := db.Query(`SELECT s.name, b.id, b.state, COALESCE(b.branch_name, ''), label_type
					  	   FROM trending_label_suggestion t
					  	   JOIN trending_label_bot_task b ON b.trending_label_suggestion_id = t.id 
					  	   JOIN label_suggestion s ON s.id = t.label_suggestion_id
						   WHERE t.closed = false AND 
						   (b.state = 'accepted' OR b.state='pending' OR b.state='building' 
						   	OR b.state='build-success' OR b.state='retry')`)
	if err != nil {
		return trendingLabels, err
	}

	defer rows.Close()

	for rows.Next() {
		var trendingLabel TrendingLabel
		err = rows.Scan(&trendingLabel.Name, &trendingLabel.BotTaskId, &trendingLabel.State, 
							&trendingLabel.BranchName, &trendingLabel.LabelType)
		if err != nil {
			return trendingLabels, err
		}

		trendingLabels = append(trendingLabels, trendingLabel)
	}

	return trendingLabels, nil
}

func generateLabelEntry(name string) (datastructures.LabelMapEntry, error) {
	var labelMapEntry datastructures.LabelMapEntry
	labelMapEntry.Description = ""
	labelMapEntry.Accessors = append(labelMapEntry.Accessors, ".")
	labelMapEntry.Plural = name + "s"

	u, err := uuid.NewV4()
	if err != nil {
		return labelMapEntry, err
	}
	labelMapEntry.Uuid = u.String()

	return labelMapEntry, nil
}

func generateMetaLabelEntry(name string) (datastructures.MetaLabelMapEntry, error) {
	var metaLabelMapEntry datastructures.MetaLabelMapEntry
	metaLabelMapEntry.Description = ""
	metaLabelMapEntry.Accessors = append(metaLabelMapEntry.Accessors, ".")	

	u, err := uuid.NewV4()
	if err != nil {
		return metaLabelMapEntry, err
	}
	metaLabelMapEntry.Uuid = u.String()

	return metaLabelMapEntry, nil
}



func main() {
	labelsRepositoryName := flag.String("labels_repository_name", "imagemonkey-trending-labels-test", "Label Repository Name")
	labelsRepositoryOwner := flag.String("labels_repository_owner", "bbernhard", "Label Repository Owner")
	metalabelsPath := flag.String("metalabels", "../wordlists/en/metalabels.jsonnet", "Path to metalabels")
	labelsPath := flag.String("labels", "../wordlists/en/labels.jsonnet", "Path to labels")
	gitCheckoutDir := flag.String("git_checkout_dir", "/tmp/labelrepository", "Git checkout directory")

	flag.Parse()

	log.SetLevel(log.DebugLevel)
	log.Info("Starting ImageMonkey Bot")

	imageMonkeyBotGithubApiToken := commons.MustGetEnv("IMAGEMONKEY_BOT_GITHUB_API_TOKEN")
	travisCiApiToken := commons.MustGetEnv("IMAGEMONKEY_TRAVIS_CI_TOKEN")

	log.Debug("Reading Metalabels")
	metaLabels := commons.NewMetaLabels(*metalabelsPath)
	err := metaLabels.Load()
	if err != nil {
		log.Fatal("Couldn't read metalabel map...terminating! ", err.Error())
	}

	log.Debug("Reading Labels")
	labels := commons.NewLabelRepository(*labelsPath)
	err = labels.Load()
	if err != nil {
		log.Fatal("Couldn't read label map...terminating!", err.Error())
	}

	//open database and make sure that we can ping it
	imageMonkeyDbConnectionString := commons.MustGetEnv("IMAGEMONKEY_DB_CONNECTION_STRING")
	db, err = sql.Open("postgres", imageMonkeyDbConnectionString)
	if err != nil {
		log.Fatal("Couldn't open database: ", err.Error())
	}

	err = db.Ping()
	if err != nil {
		log.Fatal("Couldn't ping database: ", err.Error())
	}
	defer db.Close()

	labelsRepository := NewLabelsRepository(*labelsRepositoryOwner, *labelsRepositoryName, *gitCheckoutDir)
	labelsRepository.SetToken(imageMonkeyBotGithubApiToken)

	travisCiApi := NewTravisCiApi("bbernhard", "imagemonkey-trending-labels-test")
	travisCiApi.SetToken(travisCiApiToken)

	firstIteration := true
	for {

		if !firstIteration {
			time.Sleep(1 * time.Second)
		} else {
			firstIteration = false
		}

		log.Debug("Fetch trending labels")

		trendingLabels, err := getTrendingLabels()
		if err != nil {
			log.Error("Couldn't get trending labels: ", err.Error())
			raven.CaptureError(err, nil)
		}
		for _, trendingLabel := range trendingLabels {
			labelsRepository.RemoveLocal()

			if trendingLabel.State == "accepted" {
				log.Info("Got new trending label ", trendingLabel.Name)

				if metaLabels.Contains(trendingLabel.Name) || labels.Contains(trendingLabel.Name, "") {
					err = setTrendingLabelBotTaskState("already exists", trendingLabel.BranchName, "", trendingLabel.BotTaskId)
					if err != nil {
						log.Error("Couldn't set trending label bot task state to 'already exists': ", err.Error())
						raven.CaptureError(err, nil)
					}
					continue //trendinglabel already exists
				}

				err = labelsRepository.Clone()
				if err != nil {
					log.Error(err.Error())
					raven.CaptureError(err, nil)
					continue
				}

				u, err := uuid.NewV4()
				if err != nil {
					log.Error("Couldn't create UUID: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
				trendingLabel.Name = u.String()

				branchName, err := labelsRepository.AddLabelAndPushToRepo(trendingLabel)
				if err != nil {
					log.Error("Couldn't add label: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}

				err = setTrendingLabelBotTaskState("pending", branchName, "", trendingLabel.BotTaskId)
				if err != nil {
					log.Error("Couldn't set trending label bot task state to pending: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
				trendingLabel.State = "pending"
				trendingLabel.BranchName = branchName
			}
			if trendingLabel.State == "pending" {
				err = travisCiApi.StartBuild(trendingLabel.BranchName)
				if err != nil {
					log.Error("Couldn't start travis build: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}

				err = setTrendingLabelBotTaskState("building", trendingLabel.BranchName, "", trendingLabel.BotTaskId)
				if err != nil {
					log.Error("Couldn't set trending label bot task state to building: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
			}
			if trendingLabel.State == "building" {
				travisCiBuildInfo, err := travisCiApi.GetBuildInfo(trendingLabel.BranchName)
				if err != nil {
					log.Error("Couldn't query build info for branch ", trendingLabel.BranchName, ": ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
				if travisCiBuildInfo.LastBuild.State == "started" {
					err = setTrendingLabelBotTaskState("building", trendingLabel.BranchName, travisCiBuildInfo.JobUrl, trendingLabel.BotTaskId)
					if err != nil {
						log.Error("Couldn't set trending label bot task state to build-success: ", err.Error())
						raven.CaptureError(err, nil)
						continue
					}
				} else if travisCiBuildInfo.LastBuild.State == "passed" {
					err = setTrendingLabelBotTaskState("build-success", trendingLabel.BranchName, travisCiBuildInfo.JobUrl, trendingLabel.BotTaskId)
					if err != nil {
						log.Error("Couldn't set trending label bot task state to build-success: ", err.Error())
						raven.CaptureError(err, nil)
						continue
					}
				} else if travisCiBuildInfo.LastBuild.State == "failed" {
					err = setTrendingLabelBotTaskState("build-failed", trendingLabel.BranchName, travisCiBuildInfo.JobUrl, trendingLabel.BotTaskId)
					if err != nil {
						log.Error("Couldn't set trending label bot task state to build-failed: ", err.Error())
						raven.CaptureError(err, nil)
						continue
					}
				} else if travisCiBuildInfo.LastBuild.State == "canceled" {
					err = setTrendingLabelBotTaskState("build-canceled", trendingLabel.BranchName, travisCiBuildInfo.JobUrl, trendingLabel.BotTaskId)
					if err != nil {
						log.Error("Couldn't set trending label bot task state to build-canceled: ", err.Error())
						raven.CaptureError(err, nil)
					}
				}
			}
			if trendingLabel.State == "build-success" {
				err = labelsRepository.MergeRemoteBranchIntoMaster(trendingLabel.BranchName)
				if err != nil {
					log.Error("Couldn't merge remote branch ", trendingLabel.BranchName, " into master: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
			}
			if trendingLabel.State == "retry" {
				err = labelsRepository.RemoveRemoteBranch(trendingLabel.BranchName)
				if err != nil {
					log.Error("Couldn't remove branch ", trendingLabel.BranchName, ": ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
				err = resetTrendingLabelBotTaskState(trendingLabel.BotTaskId)
				if err != nil {
					log.Error("Couldn't reset trending label bot task state: ", err.Error())
					raven.CaptureError(err, nil)
					continue
				}
			}
		}
	}
}
